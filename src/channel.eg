
require:
   events -> EventEmitter
   /dom
   jquery as jq
   bokehjs as Bokeh


provide:
   channel-constructors


class SubChannels:

   constructor(@master, @config, @install) =
      @channels = {=}

   parse(m) =
      if m.path is '/':
         return {false, m}
      {_, sub-path, *rest} = m.path.split('/')
      sub-m = m & {path = '/' + rest.join('/')}
      return {sub-path, sub-m}

   get(name, message) =
      if @channels[name] as sch:
         sch
      else:
         type = message.type or @config.type
         expr-value @channels[name] =
            channel-constructors[type](@master, @config & message) with
               data -> @install(data & {= name})

   dispatch(m) =
      {sub-path, sub-m} = @parse(m)
      if sub-path:
         ch = @get(sub-path, sub-m)
         if sub-m.path !== '/' or sub-m.command !== .open:
            ch.dispatch(sub-m)
         true
      else:
         false


class TabsChannel < EventEmitter:

   constructor(@master, message, install) =
      @master.register('_', @)
      @anchor = message.anchor or 'top'
      anchor-tag = '.tabs-{@anchor}'
      @area = dom with
         div.tabs-area[^anchor-tag] %
            div.tabs-select.hide %
            div.tabs-panes %
      @area-select = @area.child-nodes[0]
      @area-panes = @area.child-nodes[1]
      @active = null
      @nchannels = 0
      install with {
         channel = (@)
         element = @area
         message = message
      }
      @sub-channels = SubChannels(@master, cfg, install) where
         cfg = {
            type = .tabs
            anchor = @anchor
         }
         install(data) =
            data.tab = @make-tab(data)
            data.holder = dom(div % data.element)
            @area-select.append-child(data.tab)
            @area-panes.append-child(data.holder)
            if not @active:
               @select(data)
            @nchannels += 1
            if @nchannels > 1 or data.name != '_':
               @area-select.class-list.remove(.hide)

   make-tab(data) =
      dom with
         div.tab %
            data.name
            onclick() =
               @select(data)

   select(data) =
      if @active:
         @active.tab.class-list.remove(.active)
         @active.holder.class-list.remove(.active)
      data.tab.class-list.add(.active)
      data.holder.class-list.add(.active)
      @active = data

   dispatch(m) =
      m2 =
         if m.path is '/':
            m & {path = '/_', type = m.type or .log}
         else:
            m
      @sub-channels.dispatch(m2)


class LogChannel < EventEmitter:

   constructor(@master, message, install) =
      @scrolled-down = true
      @master.register('_', @)
      @area = dom with
         div.log-area %
            onscroll(e) =
               a = @jqarea
               @scrolled-down =
                  a[0].scroll-height - a.scroll-top() == a.outer-height()
      @jqarea = jq(@area)
      @input = dom with
         input.log-input %
            onkeydown(e) =
               if e.key == 'Enter':
                  @emit(.command) with {
                     type = .input
                     contents = e.target.value
                  }
                  e.target.value = ""
      @all =
         if message.has-input:
            dom(div.log-area-stack % {@area, @input})
         else:
            dom(div.log-area-stack % @area)
      install with {
         channel = (@)
         element = @all
         message = message
      }
      @sub-channels = SubChannels(@master, cfg, install) where
         cfg = {
            type = .log
         }
         install(data) =
            @area.append-child(data.element)

   dispatch(m) =
      success = @sub-channels.dispatch(m)
      if success:
         pass
      elif m.command is .log:
         element =
            match m.format:
               .pre ->
                  div.raw-line % m.contents
               .html ->
                  div[raw] % m.contents
               .markdown ->
                  require: marked
                  if m.inline:
                     div[raw] % marked.inline-lexer(m.contents, {})
                  else:
                     div[raw] % marked(m.contents, {})
               .quaint ->
                  require: quaint
                  div[raw] % quaint.toHTML(m.contents)
               else ->
                  div % m.contents
         kind = '.{m.kind or "log"}'
         @area.append-child(dom(div[^kind] % element))
         if @scrolled-down:
            set-timeout(f, 0) where f{} =
               @jqarea.scroll-top(@area.scroll-height)

      elif m.command is .clear:
         while @area.first-child:
            @area.remove-child(@area.first-child)
      elif m.command is .reprocess:
         jq(m.selector)'each'(new Function{m.body})
      else:
         console.error('log channel does not know command {m.command}.')


class PlotChannel < EventEmitter:

   constructor(@master, message, install) =
      @sources = {=}
      @master.register('_', @)
      @color-rotation = {'blue', 'red', 'green', 'purple'}
      @area = dom(div.plot-area %)
      install with {
         channel = (@)
         element = @area
         message = message
      }

      tools = "pan,crosshair,wheel_zoom,box_zoom,reset,resize,save";

      @plot = Bokeh.Plotting.figure with {
         title = 'Woo!'
         tools = tools
      }

      ;; This plot is a workaround to force the axes to show properly
      ;; even though we have no data yet.
      dummy-source = new Bokeh.ColumnDataSource with {
         data = {x = {0}, y = {0}}
      }
      l = @plot.line({field = "x"}, {field = "y"}) with {
         source = dummy-source
         line_color = .white
         line_width = 2
      }
      @plot._legend.click_policy = message.legend-click or 'hide'
      @plot._legend.location = message.legend-location or 'top_right'

      Bokeh.Plotting.show(@plot, @area)

   new-color() =
      color = @color-rotation.shift()
      @color-rotation.push(color)
      color

   add-line(opt) =
      source = new Bokeh.ColumnDataSource with {
         data = {
            x = if{opt.x, {opt.x}, {}}
            y = if{opt.x, {opt.y}, {}}
         }
      }
      ;; max-source = new Bokeh.ColumnDataSource with {
      ;;    data = {
      ;;       x = if{opt.x, {opt.x}, {}}
      ;;       y = if{opt.x, {opt.y}, {}}
      ;;    }
      ;; }
      color = opt.line-color or @new-color()
      @plot.line({field = "x"}, {field = "y"}) with {
         source = source
         line_color = color
         line_width = opt.line-width or 2
         legend = opt.legend or opt.path
      }
      ;; @plot.circle({field = "x"}, {field = "y"}) with {
      ;;    source = max-source
      ;;    size = 10
      ;;    color = color
      ;;    legend = opt.legend or opt.path
      ;; }
      ;; @sources[opt.path] = {main = source, max = max-source}
      @sources[opt.path] = {main = source}

   dispatch(m) =
      src-name = m.path[1...]
      match m.command:
         .open ->
            @add-line with m & {
               path = src-name
            }
         .point ->
            if @sources[src-name] as things:
               {main => src} = things

               src.data.x.push with m.x
               src.data.y.push with m.y
               src.change.emit()

               ;; if max.data.y < m.y:
               ;;    max.data.x[0] = m.x
               ;;    max.data.y[0] = m.y
               ;;    max.change.emit()
            else:
               @add-line({path = src-name, x = m.x, y = m.y})
         other ->
            throw Error('Unknown command: {other}')


channel-constructors = {
   error = LogChannel
   log = LogChannel
   plot = PlotChannel
   tabs = TabsChannel
}
