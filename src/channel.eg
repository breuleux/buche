
require:
   events -> EventEmitter
   /dom
   jquery as jq
   bokehjs as Bokeh
   .util -> join


provide:
   channel-constructors


jsclass UnrecognizedCommandError < Error:
   constructor(m, @channel) =
      super('Unrecognized command: {m.command}')
      @command = m.command
      @message-object = m


jsclass Channel < EventEmitter:
   constructor(@master, @options) =
      super()
      @path = @options.path
      @element = dom with @make-element()
      @setup()

   setup() =
      pass

   make-element() =
      div %

   intercepted-commands() =
      {}

   intercepts(message) =
      false

   dispatch(m and {command => match}) =
      .resource ->
         pass
         ;; @area.append-child()

      .reprocess ->
         jq(m.selector)['each'](new Function{m.body})

      else ->
         throw new UnrecognizedCommandError(m, @)

   add-channel(sub-channel) =
      @element.append-child(sub-channel.element)

   fill-sub-channel-options(options) =
      {type = .log} & options


jsclass TabsChannel < Channel:

   make-element() =
      channel-tabs %
         anchor = @options.anchor or .top

   dispatch(m) =
      @master.dispatch(m & {path = join(m.path, '_')})

   add-channel(ch, options) =
      @element.add(options.name, ch.element)

   fill-sub-channel-options(options) =
      if options.name == '_':
         ;; TabsChannel redirects its messages to tab _, which we
         ;; force to be a LogChannel
         options & {type = .log}
      else:
         {type = .tabs, anchor = @options.anchor} & options


jsclass LogChannel < Channel:

   make-element() =
      channel-log %
         onsubmit(e) =
            @emit(.command) with {
               type = .input
               contents = e.target.value
            }
            e.target.value = ""
         input = @options.has-input

   dispatch(m and {command => match}) =
      .log ->
         element =
            match m.format:
               .pre ->
                  div.raw-line % m.contents
               .html ->
                  div[raw] % m.contents
               .markdown ->
                  require: marked
                  if m.inline:
                     div[raw] % marked.inline-lexer(m.contents, {})
                  else:
                     div[raw] % marked(m.contents, {})
               .quaint ->
                  require: quaint
                  div[raw] % quaint.toHTML(m.contents)
               else ->
                  div % m.contents
         @element.add(element, m.kind or .log)

      .clear ->
         @element.clear()

      else ->
         super.dispatch(m)


jsclass PlotChannel < Channel:
   setup() =
      @sources = {=}
      @color-rotation = {'blue', 'red', 'green', 'purple'}

      tools = "pan,crosshair,wheel_zoom,box_zoom,reset,resize,save";

      @plot = Bokeh.Plotting.figure with {
         title = @options.title or null
         tools = tools
      }

      ;; This plot is a workaround to force the axes to show properly
      ;; even though we have no data yet.
      dummy-source = new Bokeh.ColumnDataSource with {
         data = {x = {0}, y = {0}}
      }
      l = @plot.line({field = "x"}, {field = "y"}) with {
         source = dummy-source
         line_color = .white
         line_width = 2
      }
      @plot._legend.click_policy = @options.legend-click or 'hide'
      @plot._legend.location = @options.legend-location or 'top_right'

      Bokeh.Plotting.show(@plot, @area)

   new-color() =
      color = @color-rotation.shift()
      @color-rotation.push(color)
      color

   make-element() =
      div.plot-area %

   dispatch(m and {command => match}) =
      .open ->
         @add-line(m)

      .point ->
         if @sources[m.sub-path or ""] as things:
            {main => src} = things

            src.data.x.push with m.x
            src.data.y.push with m.y
            src.change.emit()

            ;; if max.data.y < m.y:
            ;;    max.data.x[0] = m.x
            ;;    max.data.y[0] = m.y
            ;;    max.change.emit()
         else:
            @add-line({x = m.x, y = m.y})
      else ->
         super.dispatch(m)

   add-channel(sub-channel) =
      throw Error("Plot cannot have sub-channels.")

   fill-sub-channel-options(options) =
      null

   add-line(opt) =
      source = new Bokeh.ColumnDataSource with {
         data = {
            x = if{opt.x, {opt.x}, {}}
            y = if{opt.x, {opt.y}, {}}
         }
      }
      ;; max-source = new Bokeh.ColumnDataSource with {
      ;;    data = {
      ;;       x = if{opt.x, {opt.x}, {}}
      ;;       y = if{opt.x, {opt.y}, {}}
      ;;    }
      ;; }
      color = opt.line-color or @new-color()
      @plot.line({field = "x"}, {field = "y"}) with {
         source = source
         line_color = color
         line_width = opt.line-width or 2
         legend = opt.legend or opt.path
      }
      ;; @plot.circle({field = "x"}, {field = "y"}) with {
      ;;    source = max-source
      ;;    size = 10
      ;;    color = color
      ;;    legend = opt.legend or opt.path
      ;; }
      ;; @sources[opt.path] = {main = source, max = max-source}
      @sources[opt.path] = {main = source}
   


;; class PlotChannel < EventEmitter:

;;    constructor(@master, message, install) =
;;       @sources = {=}
;;       @master.register('_', @)
;;       @color-rotation = {'blue', 'red', 'green', 'purple'}
;;       @area = dom(div.plot-area %)
;;       install with {
;;          channel = (@)
;;          element = @area
;;          message = message
;;       }

;;       tools = "pan,crosshair,wheel_zoom,box_zoom,reset,resize,save";

;;       @plot = Bokeh.Plotting.figure with {
;;          title = message.title or null
;;          tools = tools
;;       }

;;       ;; This plot is a workaround to force the axes to show properly
;;       ;; even though we have no data yet.
;;       dummy-source = new Bokeh.ColumnDataSource with {
;;          data = {x = {0}, y = {0}}
;;       }
;;       l = @plot.line({field = "x"}, {field = "y"}) with {
;;          source = dummy-source
;;          line_color = .white
;;          line_width = 2
;;       }
;;       @plot._legend.click_policy = message.legend-click or 'hide'
;;       @plot._legend.location = message.legend-location or 'top_right'

;;       Bokeh.Plotting.show(@plot, @area)



;;    new-color() =
;;       color = @color-rotation.shift()
;;       @color-rotation.push(color)
;;       color

;;    add-line(opt) =
;;       source = new Bokeh.ColumnDataSource with {
;;          data = {
;;             x = if{opt.x, {opt.x}, {}}
;;             y = if{opt.x, {opt.y}, {}}
;;          }
;;       }
;;       ;; max-source = new Bokeh.ColumnDataSource with {
;;       ;;    data = {
;;       ;;       x = if{opt.x, {opt.x}, {}}
;;       ;;       y = if{opt.x, {opt.y}, {}}
;;       ;;    }
;;       ;; }
;;       color = opt.line-color or @new-color()
;;       @plot.line({field = "x"}, {field = "y"}) with {
;;          source = source
;;          line_color = color
;;          line_width = opt.line-width or 2
;;          legend = opt.legend or opt.path
;;       }
;;       ;; @plot.circle({field = "x"}, {field = "y"}) with {
;;       ;;    source = max-source
;;       ;;    size = 10
;;       ;;    color = color
;;       ;;    legend = opt.legend or opt.path
;;       ;; }
;;       ;; @sources[opt.path] = {main = source, max = max-source}
;;       @sources[opt.path] = {main = source}

;;    dispatch(m) =
;;       src-name = m.path[1...]
;;       match m.command:
;;          .open ->
;;             @add-line with m & {
;;                path = src-name
;;             }
;;          .point ->
;;             if @sources[src-name] as things:
;;                {main => src} = things

;;                src.data.x.push with m.x
;;                src.data.y.push with m.y
;;                src.change.emit()

;;                ;; if max.data.y < m.y:
;;                ;;    max.data.x[0] = m.x
;;                ;;    max.data.y[0] = m.y
;;                ;;    max.change.emit()
;;             else:
;;                @add-line({path = src-name, x = m.x, y = m.y})
;;          other ->
;;             throw Error('Unknown command: {other}')


channel-constructors = {
   ;; error = LogChannel
   log = LogChannel
   plot = PlotChannel
   tabs = TabsChannel
}
