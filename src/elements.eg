
require:
   fs
   "./format" -> format
   .util -> format-buche-exception
   /dom


provide:
   extract-config
   BucheElement
   custom-elements
   make-nodes
   element-to-command


globals:
   HTMLElement, Text, custom-elements, CustomElementRegistry, Event


adjust-attributes(clone! attrs) =
   items(attrs) each {k, match v} ->
      === true ->
         attrs[k] = ""
      === false ->
         delete attrs[k]
      else ->
         pass
   attrs


make-nodes(match message, fmt) =
   undefined? or null? ->
      {}
   String? or ENode? or HTMLElement? ->
      Array! format(fmt, message)
   Array? ->
      (message each x -> make-nodes(x, fmt)).reduce(++)
   {=> tag} ->
      new-children = make-nodes(message.content, message.format or .html)
      attrs = adjust-attributes(message.attributes or {=})
      enode = ENode(tag, attrs, new-children)
      {dom(enode)}
   {=> src} ->
      content = fs.read-file-sync(src, .utf8)
      parts = src.split('.')
      ext = parts[parts.length - 1]
      make-nodes(content, message.format or ext)
   {=> content} ->
      make-nodes(content, message.format or .html)
   else ->
      throw Error('Cannot make a node out of this.')


method HTMLElement.prototype.dispatch(cmd, data) =
   m = @['command_{cmd}']
   if m:
      m.call(@, cmd, data)
   else:
      e = new Error('Unrecognized command: {cmd}')
      e.json-message = {command = cmd, data = data}
      throw e


method HTMLElement.prototype.command_log(_, data) =
   make-nodes(data) each
      HTMLElement? node ->
         match node.tag-name.to-lower-case():
            R"^command-([a-z]+)$"! {_, command-name} ->
               dat = element-to-command(node, command-name)
               @dispatch(dat.command, dat.data)
            else ->
               @append-child(node)
      node ->
         @append-child(node)


method HTMLElement.prototype.command_clear(_, data) =
   @innerHTML = ""


method HTMLElement.prototype.buche-dispatcher() =
   var root = [@]
   while not root._buche-dispatcher:
      root = root.parent-node
   root._buche-dispatcher


method HTMLElement.prototype.buche-send(obj, arg) =
   message = match obj:
      Event? ->
         obj.stop-propagation()
         {
            path = @buche-path or null
            event-type = obj.type
            modifiers = {
               ctrl = obj.ctrl-key
               shift = obj.shift-key
               alt = obj.alt-key
               meta = obj.meta-key
            }
            address = @get-attribute(.address)
            which = obj.which
         }
      Number? or String? ->
         {
            path = @buche-path or null
            argument = obj
         }
      else ->
         obj

   if typeof(arg) is .object:
      Object.assign(message, arg)
   else:
      message.argument = arg

   message.path or= @buche-path or null

   @buche-dispatcher().source.send(message)


element-to-command(node, command) =
   children = node.child-nodes each match ->
      Text? t when t.data.trim() == "" -> continue
      ch -> ch

   data = {=}

   node.attributes each attr ->
      data[attr.name] = match attr.value:
         "" -> true
         else ->
            try:
               JSON.parse(attr.value)
            catch err:
               attr.value

   match children:
      {} -> pass
      {match ch} ->
         HTMLElement? {tag-name => "SCRIPT", type => "application/json"} ->
            data &: JSON.parse(ch.text-content)
         HTMLElement? {tag-name => "SCRIPT", type => ""} ->
            data &: JSON.parse(ch.text-content)
         else ->
            data.children = {ch}
      else ->
         data.children = node.child-nodes

   return {=command, =data}


extract-config(@) =
   spec = @attribute-spec()
   config = @attribute-defaults()
   @attributes each attr ->
      name = attr.name
      v =
         if spec[name]:
            spec[name](attr.value)
         else:
            attr.value
      config[name] = v
   items(adjust-attributes(config)) each {name, v} ->
      @set-attribute(name, v)
   config


jsclass BucheElement < HTMLElement:

   constructor() =
      super()
      @_locked = false

   attribute-defaults() =
      {=}

   attribute-spec() =
      {=}

   _lock() =
      if not @_locked:
         @_locked = true
         config = extract-config(@)
         commands = {}
         children = @child-nodes each
            HTMLElement? node ->
               match node.tag-name.to-lower-case():
                  R"^command-([a-z]+)$"! {_, command-name} ->
                     dat = element-to-command(node, command-name)
                     commands.push with {dat.command, dat.data}
                  else ->
                     node
            other -> other
         @innerHTML = ""
         @setup(config, children)
         commands each {cmd, dat} ->
            @dispatch(cmd, dat)

   setup(config, children) =
      @config = config
      children each ch ->
         @push-child(ch)

   connected-callback() =
      try:
         @_lock()
      catch err:
         m = @innerHTML
         @buche-dispatcher()._dispatch(format-buche-exception(m, err))

   append-child(ch) =
      if @_locked:
         @push-child(ch)
      else:
         super.append-child(ch)

   _append-child(ch) =
      super.append-child(ch)


jsclass PlaceholderElement < HTMLElement:
   constructor() =
      super()

   connected-callback() =
      tag = @get-attribute(.tag)
      @set-attribute(.title) with
         'Undefined tag: <{tag}>. You may need to install a plugin.'
      @append-child(dom('<{tag}>'))


_standard-hyphenated = {
   "annotation-xml" = true
   "color-profile" = true
   "font-face" = true
   "font-face-src" = true
   "font-face-uri" = true
   "font-face-format" = true
   "font-face-name" = true
   "missing-glyph" = true
}


CustomElementRegistry.prototype.is-valid-name(name) =
   ;; This is not exhaustive. Actual spec at:
   ;; https://www.w3.org/TR/custom-elements/#valid-custom-element-name
   R"[a-z_]+-[a-z_]+"? name and not _standard-hyphenated[name]


elements-map = {
   "placeholder-element" = PlaceholderElement
}


items(elements-map) each {tag, cls} ->
   custom-elements.define(tag, cls)
