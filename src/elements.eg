
require:
   "./format" -> format
   /dom


provide:
   custom-elements
   make-nodes


globals:
   HTMLElement, custom-elements, CustomElementRegistry


make-nodes(match message, fmt) =
   undefined? or null? ->
      {}
   String? ->
      Array! format(fmt, message)
   Array? ->
      message.map(make-nodes).reduce(++)
   {=> tag} ->
      new-children = make-nodes(message.children, message.format or .html)
      enode = ENode(tag, props, new-children) where props =
         object with items(message) each {match k, v} ->
            .tag or .children ->
               continue
            else ->
               {k, v}
      {dom(enode)}
   {=> children} ->
      make-nodes(children, message.format or .html)
   else ->
      throw Error('Cannot make a node out of this.')


method HTMLElement.prototype.dispatch(cmd, data) =
   m = @['command_{cmd}']
   if m:
      m.call(@, cmd, data)
   else:
      throw new Error('Unrecognized command: {cmd}')


method HTMLElement.prototype.command_log(_, data) =
   make-nodes(data) each node ->
      @append-child(node)


method HTMLElement.prototype.command_clear(_, data) =
   @innerHTML = ""


jsclass PlaceholderElement < HTMLElement:
   constructor() =
      super()

   connected-callback() =
      tag = @get-attribute(.tag)
      @set-attribute(.title) with
         'Undefined tag: <{tag}>. You may need to install a plugin.'
      @append-child(dom('<{tag}>'))


_standard-hyphenated = {
   "annotation-xml" = true
   "color-profile" = true
   "font-face" = true
   "font-face-src" = true
   "font-face-uri" = true
   "font-face-format" = true
   "font-face-name" = true
   "missing-glyph" = true
}


CustomElementRegistry.prototype.is-valid-name(name) =
   ;; This is not exhaustive. Actual spec at:
   ;; https://www.w3.org/TR/custom-elements/#valid-custom-element-name
   R"[a-z_]+-[a-z_]+"? name and not _standard-hyphenated[name]


elements-map = {
   "placeholder-element" = PlaceholderElement
}


items(elements-map) each {tag, cls} ->
   custom-elements.define(tag, cls)
