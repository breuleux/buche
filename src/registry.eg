
require:
   fs
   path
   expand-tilde
   mkdirp
   events as abc -> EventEmitter


provide:
   events
   import-failures
   ImportError
   DelayMessage
   config
   config-path
   channel-constructors
   channel-elements
   load-plugin
   install-plugin
   uninstall-plugin
   register-element
   make-installer-component


globals:
   document


events = new EventEmitter()


import-failures = {=}


jsclass ImportError < Error:
   constructor(message) =
      super(message)


class DelayMessage:
   constructor(@token, @message) =
      pass


config-path(name='') =
   base = expand-tilde('~/.config/buche/')
   path.join(base, name)


get-config() =
   if not fs.exists-sync(config-path()):
      mkdirp.sync(config-path())
      mkdirp.sync(config-path('node_modules'))
      {'package.json', 'index.js'} each file ->
         fs.write-file-sync(config-path(file)) with
            fs.read-file-sync(p, .utf8) where p =
               path.join(__dirname, '../default-config', file)


config = get-config()
rq = require
rquser = rq(config-path('index.js')).require
channel-constructors = {=}
channel-elements = {=}


require-plugin(p) =
   candidates = {{rq, './plugins/{p}'}, {rquser, 'buche-{p}'}}
   candidates each {rqfn, candidate} ->
      try:
         return rqfn(candidate)
      catch e:
         if e.message !== 'Cannot find module \'{candidate}\'':
            throw e
         pass
   import-failures[p] = true
   throw new ImportError('Cannot find plugin "{p}". Try: `buche --install {p}`')


load-plugin(match p, exact = true) =
   String? when exact ->
      full-path =
         match p:
            R"^/"? -> p
            else -> path.join(process.cwd(), p)
      plugin = rq(full-path)
      plugin._buche_name = p
      load-plugin(plugin)
   String? ->
      plugin = require-plugin(p)
      plugin._buche_name = p
      load-plugin(plugin)
   else ->
      if not p.is-buche-plugin:
         throw new Error('"{p._buche_name}" is not a valid Buche plugin.')
      items(p.channels or {=}) each {name, cls} ->
         events.emit('add-channel-type', name, cls)
         events.emit('add-channel-type-{name}', cls)
         channel-constructors[name] = cls
      items(p.components or {=}) each {name, cls} ->
         events.emit('add-component-type', name, cls)
         events.emit('add-component-type-{name}', cls)
         document.register-element(name, cls)


async npm-instance() =
   require: npm
   load = promisify(npm.load)
   await load(JSON.parse(fs.readFileSync(config-path('package.json'))))


async install-plugin(name) =
   npm = await npm-instance()
   npm.prefix = config-path()
   install = promisify(npm.install)
   await install('buche-{name}')


async uninstall-plugin(name) =
   npm = await npm-instance()
   npm.prefix = config-path()
   uninstall = promisify(npm.uninstall)
   await uninstall('buche-{name}')
   

register-element(name, cls) =
   channel-elements[name] = cls
   document.register-element(name, cls)


make-installer-component(name, message) =
   div.install-request %
      style % """
         .install-request {
            background: #eee;
            padding: 10px;
         }
         .install-button {
            padding: 5px;
         }
         .install-error {
            padding: 5px;
            color: red;
            font-weight: bold;
         }
         .install-installing {
            padding: 5px;
         }
         .install-done {
            padding: 5px;
            color: green;
            font-weight: bold;
         }
      """
      div.install-message %
         message
      div.install-button % button %
         'Install'
         method onclick(e) =
            ;; TODO: dismiss the install button when the package is
            ;; installed from elsewhere.
            ;; TODO: "Retry import" button?
            f() where async f() =
               parent = @parent-node
               parent.innerHTML = "Installing..."
               parent.className = 'install-installing'
               try:
                  await install-plugin(name)
                  delete import-failures[name]
               catch e:
                  parent.innerHTML = e.message
                  parent.className = 'install-error'
                  return
               try:
                  load-plugin(name, false)
               catch e:
                  parent.innerHTML = e.message
                  parent.className = 'install-error'
                  return
               parent.innerHTML = "Done!"
               parent.className = 'install-done'
