
require:
   events -> EventEmitter
   .elements -> custom-elements
   "./format" -> format
   /dom


provide:
   RootDispatcher


globals:
   document, MutationObserver, Element, Text


class InteractiveDocument < EventEmitter:

   constructor(@container) =
      @channels = {=}
      @create-channel('/', @container)
      @add-channels-from(@container.child-nodes, @container)

   create-channel(path, element) =
      element.buche-path = path
      @channels[path] = element
      @emit('add-channel', path, element)
      @emit(path, element)
      @obs = new MutationObserver with (muts each mut) ->
         @insert-placeholders(mut.added-nodes, mut.target)
         @add-channels-from(mut.added-nodes, mut.target)
         @remove-channels-from(mut.removed-nodes, mut.target)
      @obs.observe(@container) with {
         child-list = true
         subtree = true
      }

   async schedule-placeholder-removal(tag-name, ph, ch) =
      await custom-elements.when-defined(tag-name)
      ph.parent-node.replace-child(ch, ph)

   insert-placeholders(match node, parent) =
      ;; Any undefined custom element is replaced by an informative
      ;; placeholder until the required plugin is installed.
      Element? and match is node.tag-name.to-lower-case() ->
         do:
            @insert-placeholders(node.child-nodes, node)
         name when custom-elements.is-valid-name(name)
                   \ and custom-elements.get(name) is undefined ->
            ph = dom with
               placeholder-element %
                  tag = name
            parent.replace-child(ph, node)
            @schedule-placeholder-removal(name, ph, node)
         else ->
            pass
      Text? ->
         pass
      else ->
         node each x -> @insert-placeholders(x, parent)

   add-channels-from(match node, var parent) =
      Element? ->
         match node.get-attribute('address') as addr:
            undefined? or null? ->
               pass
            R"^/"? ->
               @create-channel(addr, node)
            else ->
               while not parent.buche-path:
                  parent = parent.parent-node
               prefix = parent.buche-path.replace(R"/+$", "")
               full-addr = '{prefix}/{addr}'
               @create-channel(full-addr, node)
         @add-channels-from(node.child-nodes, parent)
      Text? ->
         pass
      else ->
         node each x -> @add-channels-from(x, parent)

   remove-channels-from(match node, parent) =
      Element? ->
         ;; TODO
         pass
         ;; throw Error('Cannot remove nodes at the moment.')
      Text? ->
         pass
      else ->
         node each x -> @remove-channels-from(x, parent)


make-nodes(match message, fmt) =
   undefined? or null? ->
      {}
   String? ->
      Array! format(fmt, message)
   Array? ->
      message.map(make-nodes).reduce(++)
   {=> tag} ->
      new-children = make-nodes(message.children, message.format or .html)
      enode = ENode(tag, props, new-children) where props =
         object with items(message) each {match k, v} ->
            .tag or .children ->
               continue
            else ->
               {k, v}
      {dom(enode)}
   {=> children} ->
      make-nodes(children, message.format or .html)
   else ->
      throw Error('Cannot make a node out of this.')


class RootDispatcher < EventEmitter:

   constructor(@source, @container, @plugins) =
      @doc = InteractiveDocument(@container)
      @waitlist = {=}

   dispatch(message and match is message.command) =
      do:
         clone! m = message
         channel-name = m.parent
         delete m.parent
      .resource ->
         if channel-name is not undefined:
            throw Error('resource command should not set parent field')
         make-nodes(message) each node ->
            document.head.append-child(node)
      .plugin ->
         if channel-name is not undefined:
            throw Error('plugin command should not set parent field')
         @plugins.load(message.name)
      .error ->
         console.error('[E] {message.type}: {message.message}')
         console.error(message.data)

      do:
         channel = channel-name and @doc.channels[channel-name]
      when channel is undefined ->
         ;; We stash the message until its parent channel has been created.
         match @waitlist[channel-name]:
            undefined? ->
               w = {}
               @waitlist[channel-name] = w
               w.push(message)
               @doc.once(channel-name) with element ->
                  delete @waitlist[channel-name]
                  w each m ->
                     @dispatch(m)
            w ->
               w.push(message)
      .log or undefined? ->
         make-nodes(m) each node ->
            channel.append-child(node)
      .clear ->
         if channel.clear:
            channel.clear()
         else:
            channel.innerHTML = ""
      cmd ->
         throw 'Unknown command: {cmd}'

   run() =
      @source.read(m -> @dispatch(m))
