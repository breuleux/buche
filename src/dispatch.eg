
require:
   events -> EventEmitter
   buche-tools -> BucheError
   .registry ->
      DelayMessage
      ImportError, channel-constructors
      load-plugin, install-plugin
   .util ->
      buche-exception-message

provide:
   RootDispatcher

globals:
   document


;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Load default plugins ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;


{.nil, .placeholder, .redirect, .goodies
 .log, .tabs, .slides, .template} each default-plugin ->
   load-plugin(default-plugin, false)


;; buche-error-channel = '/!buche-errors'
buche-error-channel = '/ðŸž'
buche-settings-channel = '/âš™ï¸'


gen hierarchy(path) =
   parts = path.split('/')
   last = parts.pop()
   2..parts.length each i ->
      yield parts.join('/')
      parts.pop()
   yield "/"


split-end(path) =
   parts = path.split('/')
   last = parts.pop()
   {parts.join('/') or '/', last or null}


class RootDispatcher < EventEmitter:

   constructor(@source, @target) =
      @set-max-listeners(Infinity)
      @channels = {=}
      @intercepts = {=}
      @delayed = {=}
      @channel-options = {
         buche-error-channel => {
            type = .log
            order = 100000
         }
         buche-settings-channel => {
            type = .log
            order = 100001
         }
      }

   find-channel(path) =
      ch = @channels[path]
      if not ch:
         {p, c} = split-end(path)
         @open(p, c, (@channel-options[path] or {=}) & {path = path})
      else:
         ch

   open(parent-path, name, base-options) =
      options = base-options & {
         parent-path = parent-path
         name = name
      }
      if parent-path == '/' and not name:
         @construct(null, .tabs, options)
      else:
         parent = @find-channel(parent-path)
         parent.open-channel(options)

   construct(parent-channel, type, options) =
      cls = channel-constructors[type]
      if not cls:
         return @construct(parent-channel, 'placeholder') with options & {
            _placeholder-type = type
         }
         ;; return @construct(parent-channel, 'nil') with options & {
         ;;    message = '''
         ;;    <p>Failed to open channel of type <b>{type}</b></p>

         ;;    <p>That channel may be available as a plugin. If that plugin
         ;;    is installed, you may be able to use it by printing out this
         ;;    JSON command before opening the channel:</p>

         ;;    <pre>\{"command": "require", "path": "/", "pluginName": "{type}"\}</pre>

         ;;    <p>This assumes the plugin name is the same as the channel.</p>

         ;;    <p>If the plugin is not installed, try to install it with the
         ;;    following command:</p>

         ;;    <pre>buche --install {type}</pre>
         ;;    '''
         ;;    format = .html
         ;; }
      ch = new cls(@, options)
      if parent-channel is null:
         @target.append-child(ch.element)
      expr-value @channels[options.path] = ch

   dispatch(message) =
      {'path', 'command'} each field ->
         if not message[field]:
            err = new BucheError('Missing field in message: "{field}"', message) with {
               fields = {field}
               channel = {path = '/'}
            }
            @dispatch(buche-exception-message(err, buche-error-channel))
            return

      try:
         if message.command is 'require':
            if message.plugin-path:
               load-plugin(message.plugin-path)
            else:
               name = message.plugin-name
               try:
                  load-plugin(name, false)
               catch ImportError? e:
                  @dispatch with {
                     path = buche-error-channel,
                     command = .log,
                     format = ._enode,
                     gutter = .error,
                     content =
                        div.install-request %
                           div.install-message % span %
                              'Package '
                              b % name
                              ' is required, '
                              'but it is not installed. '
                              br %
                              'Do you want to try installing it?'
                           div.install-button % button %
                              'Install'
                              method onclick(e) =
                                 f() where async f() =
                                    parent = @parent-node
                                    parent.innerHTML = "Installing..."
                                    parent.className = 'install-installing'
                                    try:
                                       await install-plugin(name)
                                    catch e:
                                       parent.innerHTML = e.message
                                       parent.className = 'install-error'
                                       return
                                    try:
                                       load-plugin(name, false)
                                    catch e:
                                       parent.innerHTML = e.message
                                       parent.className = 'install-error'
                                       return
                                    parent.innerHTML = "Done!"
                                    parent.className = 'install-done'
                                 }
            return

         path = message.path
         if @intercepts[message.command]:
            hierarchy(path) each p ->
               if @channels[p] as ch:
                  if ch.intercepts(message):
                     return ch.dispatch(message)
         if message.command is .open:
            if message.wait-for-message:
               @channel-options[path] = message
            else:
               {p, c} = split-end(path)
               @open(p, c, message)
         else:
            @find-channel(path).dispatch(message)
      catch DelayMessage? delay:
         (@delayed[delay.token] or= {}).push(message)
      catch BucheError? err:
         @dispatch(buche-exception-message(err, buche-error-channel))
      catch Error? e:
         err = new BucheError(e.message, message, {orig-error = e})
         @dispatch(buche-exception-message(err, buche-error-channel))

   unblock-messages(token) =
      messages = @delayed[token] or {}
      delete @delayed[token]
      messages each m ->
         @dispatch(m)

   run() =
      @source.read(m -> @dispatch(m))

   send(message) =
      @source.send(message)
