
require:
   events -> EventEmitter
   .elements ->
      custom-elements, make-nodes, element-to-command
   .util ->
      format-buche-exception
   /dom


provide:
   RootDispatcher


globals:
   document, MutationObserver, Element, Text


class InteractiveDocument < EventEmitter:

   constructor(@container, @dispatcher) =
      @channels = {=}
      @add-channels-from(@container.child-nodes, @container)
      @container._buche-dispatcher = @dispatcher

   create-channel(path, element) =
      element.buche-path = path
      @channels[path] = element
      @emit('add-channel', path, element)
      @emit(path, element)
      @obs = new MutationObserver with (muts each mut) ->
         @insert-placeholders(mut.added-nodes, mut.target)
         @add-channels-from(mut.added-nodes, mut.target)
         @remove-channels-from(mut.removed-nodes, mut.target)
      @obs.observe(@container) with {
         child-list = true
         subtree = true
      }

   async schedule-placeholder-removal(tag-name, ph, ch) =
      await custom-elements.when-defined(tag-name)
      ph.parent-node.replace-child(ch, ph)

   insert-placeholders(match node, parent) =
      ;; Any undefined custom element is replaced by an informative
      ;; placeholder until the required plugin is installed.
      ;; Also, <command-*> tags are removed and their JSON content
      ;; is dispatched to the parent as a command.
      Element? and {buche-data => data and {state => "ok"}} ->
         parent.dispatch(data.command, data.data)
         parent.remove-child(node)
      Element? and match is node.tag-name.to-lower-case() ->
         R"^command-([a-z]+)$"! {_, command-name} ->
            data = element-to-command(node, command-name)
            parent.dispatch(data.command, data.data)
            parent.remove-child(node)
         do:
            @insert-placeholders(consume(node.child-nodes), node)
         name when custom-elements.is-valid-name(name)
                   \ and custom-elements.get(name) is undefined ->
            ph = dom with
               placeholder-element %
                  tag = name
            parent.replace-child(ph, node)
            @schedule-placeholder-removal(name, ph, node)
         else ->
            pass
      Text? ->
         pass
      else ->
         node each x -> @insert-placeholders(x, parent)

   add-channels-from(match node, var parent) =
      Element? ->
         match node.get-attribute('address') as addr:
            undefined? or null? ->
               pass
            R"^/"? ->
               @create-channel(addr, node)
            else ->
               while not parent.buche-path:
                  parent = parent.parent-node
               prefix = parent.buche-path.replace(R"/+$", "")
               full-addr = '{prefix}/{addr}'
               @create-channel(full-addr, node)
         @add-channels-from(node.child-nodes, parent)
      Text? ->
         pass
      else ->
         node each x -> @add-channels-from(x, parent)

   remove-channels-from(match node, parent) =
      Element? ->
         ;; TODO
         pass
         ;; throw Error('Cannot remove nodes at the moment.')
      Text? ->
         pass
      else ->
         node each x -> @remove-channels-from(x, parent)


class RootDispatcher < EventEmitter:

   constructor(@source, @container, @plugins) =
      @doc = InteractiveDocument(@container, @)
      @waitlist = {=}

   _dispatch(message and match is message.command) =
      do:
         clone! m = message
         channel-name = m.parent
         delete m.parent
         delete m.command
      .resource ->
         if channel-name is not undefined:
            throw Error('resource command should not set parent field')
         make-nodes(message) each node ->
            document.head.append-child(node)
      .plugin ->
         if channel-name is not undefined:
            throw Error('plugin command should not set parent field')
         @plugins.load(message.name)
      .error ->
         console.error('[E] {message.type}: {message.message}')
         console.error(message.data)

      when channel-name is undefined ->
         throw Error("'parent' field was not set in command")

      do:
         channel = channel-name and @doc.channels[channel-name]
      when channel is undefined ->
         ;; We stash the message until its parent channel has been created.
         match @waitlist[channel-name]:
            undefined? ->
               w = {}
               @waitlist[channel-name] = w
               w.push(message)
               @doc.once(channel-name) with element ->
                  delete @waitlist[channel-name]
                  w each m ->
                     @_dispatch(m)
            w ->
               w.push(message)

      cmd ->
         channel.dispatch(cmd or 'log', m)

   dispatch(message) =
      try:
         @_dispatch(message)
      catch err:
         @_dispatch(format-buche-exception(message, err))

   run() =
      @source.read(m -> @dispatch(m))
