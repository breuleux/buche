
require:
   electron ->
      app, BrowserWindow, ipc-main
   fs
   path
   minimist
   shell-escape
   child_process ->
      spawn
   open
   ..package -> version
   .registry ->
      install-plugin, uninstall-plugin, resolve-plugin
   .util ->
      buche-error-channel
   /html

var main-window = null
var proc = null

usage = """
Usage: buche [options] [command]

Options:

  --tee [file]         File to log the command's stdout to.
  --inspect            Print stdout and stdin.
  --install plugin     Install a buche plugin.
  --uninstall plugin   Uninstall a buche plugin.
  --dev                Open developer console.
  --dump               Don't open a window, just print on stdout.
  -r [plugins]         Require the given plugins.
  -h, --help           Output usage information.
  -v, --version        Output the version number.

Note:
   The options must come before the command. Any options written
   after the command are the options for that command.
"""

async parse-options(argv) =
   var help = false
   cfg = {
      boolean = {'dev', 'dump', 'inspect', 'version', 'help'}
      string = {'tee', 'install', 'uninstall', 'require'}
      alias = {
         v = .version
         h = .help
         t = .tee
         r = .require
      }
      stop-early = true
      unknown(match x) =
         R"^-"? ->
            console.error('Unknown option: {x}')
            help = true
            false
         else ->
            true
   }
   opts = minimist(argv, cfg)
   if opts.r:
      reqs = {}
      opts.r.split(',') each plugin ->
         try:
            pkg = resolve-plugin('{plugin}/package.json')
            if pkg.buche and pkg.buche??.requireHowto:
               reqs.push({plugin, true, pkg.buche.requireHowto})
            else:
               reqs.push({plugin, false, new Error(___)}) with
                  'There is no "buche.requireHowto" key in the plugin\'s package.json'
         catch e:
            reqs.push({plugin, false, e})
      opts.r = reqs
   if help or opts.help:
      if opts.r:
         opts.r each {plugin, match success, value} ->
            true? ->
               console.error('Require `{plugin}` by printing this:')
               console.error('  {JSON.stringify(value)}')
            else ->
               console.error('No help available about requiring `{plugin}`')
               console.error('  {value??.message}')
      else:
         console.error(usage)
      null
   elif opts.dump:
      if not opts.r or opts._.length > 0:
         console.error('--dump only works with -r option for now')
      else:
         opts.r each {plugin, success, value} when success ->
            print JSON.stringify(value)
      null
   elif opts.version:
      print 'buche v{version}'
      null
   elif opts.install:
      await install-plugin(opts.install)
      null
   elif opts.uninstall:
      await uninstall-plugin(opts.uninstall)
      null
   else:
      opts.cmd = match opts._:
         {cmd} -> cmd
         args -> shell-escape(args)
      opts


create-window(options) =

   cmd = options.cmd
   if cmd:
      print 'Using command: {cmd}'

   var show-splash = if{cmd, false, true}

   stream =
      if options.tee:
         print 'Logging into: {options.tee}'
         fs.create-write-stream(options.tee)
      else:
         null

   w = new BrowserWindow with {
      width = 1200
      height = 900
      title = cmd or 'buche'
      web-preferences = {
         experimental-features = true
      }
   }

   w.loadURL('file://{__dirname}/../html/index.html')
   if options.dev:
      w.web-contents.open-dev-tools(mode = .bottom)
   w.on(.closed) with {} ->
      main-window = null

   handle-redirect(e, url) =
      if url != w.web-contents.getURL():
        e.preventDefault()
        open(url)

   w.web-contents.on('will-navigate', handle-redirect)
   w.web-contents.on('new-window', handle-redirect)

   web-send(data, trail = '\n') =
      show-splash = false
      if stream:
         stream.write(data)
      if options.inspect:
         data.split('\n') each line when line ->
            print '-> {line}'
      try:
         w.web-contents.send(.data, data + trail)
      catch e:
         console.error(e.stack)

   splash() =
      data = {
         command = .log
         path = '/ℹ️'
         format = .markdown
         content = fs.read-file-sync('{__dirname}/../html/splash.md', .utf8)
      }
      web-send(JSON.stringify(data))

   ipc-main.on(.ready) with ->
      var origins = {}
      if options.r:
         options.r each {plugin, match success, value} ->
            true? -> web-send(JSON.stringify(value))
            else -> pass  ;; TODO: show error

      if cmd:
         proc = spawn(cmd, {}) with {
            shell = true
            stdio = {.pipe, .pipe, .pipe} ;; process.stderr}
         }
         proc.on(.error) with err ->
            print 'Failed to start process.'
            print err
         origins = {proc.stdout, proc.stderr}
         ipc-main.on(.data) with {_, data} ->
            if options.inspect:
               print '<- {data}'
            try:
               proc.stdin.write(data + '\n')
            catch e:
               web-send(.data, JSON.stringify(___)) with {
                  command = .log
                  path = buche-error-channel
                  gutter = .error
                  format = .html
                  content = html with
                     div.buche-error %
                        div.buche-error-reason %
                           "A message was sent to the command's standard input,"
                           " but an error occurred:"
                           div % e.message
                        pre %
                           data
               }
      else:
         origins = {process.stdin}
         ipc-main.on(.data) with {_, data} ->
            console.error('Cannot receive data!')
            console.error(JSON.stringify(data))
      origins each origin ->
         origin.set-encoding(.utf8)
         origin.on(.data) with data ->
            web-send(data, '')
         origin.on(.end) with ->
            if show-splash:
               splash()
            try:
               w.web-contents.send(.end)
            catch e:
               console.error(e.stack)

      if show-splash and process.stdin.isTTY:
         splash()
         show-splash = false

main() where async main() =
   options = await parse-options(process.argv[cut...]) where cut =
      if path.resolve(process.argv[1]) is __filename:
         2
      else:
         1

   if options is null:
      process.exit(0)

   app.on('ready') with _ -> create-window(options)

   app.on("window-all-closed") with {} ->
      app.quit()
      if proc:
         proc.stdin.end()

   app.on(.activate) with {} ->
      if main-window === null:
         create-window(options)
