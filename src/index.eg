
require:
   electron ->
      app, BrowserWindow, ipc-main
   fs
   path
   minimist
   shell-escape
   child_process ->
      spawn
   open
   ..package -> version
   .registry ->
      install-plugin, uninstall-plugin
   .util ->
      buche-error-channel
   /html

var main-window = null
var proc = null

usage = """
Usage: buche [options] [command]

Options:

  --tee [file]         File to log the command's stdout to.
  --inspect            Print stdout and stdin.
  --install plugin     Install a buche plugin.
  --uninstall plugin   Uninstall a buche plugin.
  --dev                Open developer console.
  -h, --help           Output usage information.
  -v, --version        Output the version number.

Note:
   The command must come after the options. Any options written
   after the command are the options for that command.
"""

async parse-options(argv) =
   var help = false
   cfg = {
      boolean = {'dev', 'inspect', 'version', 'help'}
      string = {'tee', 'install', 'uninstall'}
      alias = {
         v = .version
         h = .help
         t = .tee
      }
      stop-early = true
      unknown(match x) =
         R"^-"? ->
            console.error('Unknown option: {x}')
            help = true
            false
         else ->
            true
   }
   opts = minimist(argv, cfg)
   if help or opts.help:
      console.error(usage)
      null
   elif opts.version:
      print 'Buche v{version}'
      null
   elif opts.install:
      await install-plugin(opts.install)
      null
   elif opts.uninstall:
      await uninstall-plugin(opts.uninstall)
      null
   else:
      opts.cmd = match opts._:
         {cmd} -> cmd
         args -> shell-escape(args)
      opts


create-window(options) =
   
   cmd =
      if options.cmd:
         if options.tee:
            '{options.cmd} | tee {options.tee}'
         else:
            options.cmd
      elif options.tee:
         print '--tee only works with -c option for now.'
         process.exit(1)
      else:
         null

   w = new BrowserWindow with {
      width = 1200
      height = 900
      web-preferences = {
         experimental-features = true
      }
   }

   w.loadURL('file://{__dirname}/../html/index.html')
   if options.dev:
      w.web-contents.open-dev-tools(mode = .bottom)
   w.on(.closed) with {} ->
      main-window = null

   handle-redirect(e, url) =
      if url != w.web-contents.getURL():
        e.preventDefault()
        open(url)

   w.web-contents.on('will-navigate', handle-redirect)
   w.web-contents.on('new-window', handle-redirect)

   web-send(data, trail = '\n') =
      try:
         w.web-contents.send(.data, data + trail)
      catch e:
         console.error(e.stack)

   ipc-main.on(.ready) with ->
      var origins = {}
      if cmd:
         print 'Using command: {cmd}'
         proc = spawn(cmd, {}) with {
            shell = true
            stdio = {.pipe, .pipe, .pipe} ;; process.stderr}
         }
         proc.on(.error) with err ->
            print 'Failed to start process.'
            print err
         origins = {proc.stdout, proc.stderr}
         ipc-main.on(.data) with {_, data} ->
            if options.inspect:
               print '<- {data}'
            try:
               proc.stdin.write(data + '\n')
            catch e:
               web-send(.data, JSON.stringify(___)) with {
                  command = .log
                  path = buche-error-channel
                  gutter = .error
                  format = .html
                  content = html with
                     div.buche-error %
                        div.buche-error-reason %
                           "A message was sent to the command's standard input,"
                           " but an error occurred:"
                           div % e.message
                        pre %
                           data
               }
      else:
         origins = {process.stdin}
         ipc-main.on(.data) with {_, data} ->
            console.error('Cannot receive data!')
            console.error(JSON.stringify(data))
      origins each origin ->
         origin.set-encoding(.utf8)
         origin.on(.data) with data ->
            if options.inspect:
               data.split('\n') each line when line ->
                  print '-> {line}'
            web-send(data, '')
         origin.on(.end) with ->
            try:
               w.web-contents.send(.end)
            catch e:
               console.error(e.stack)


main() where async main() =
   options = await parse-options(process.argv[2...])

   if options is null:
      process.exit(1)

   app.on('ready') with _ -> create-window(options)

   app.on("window-all-closed") with {} ->
      app.quit()
      if proc:
         proc.stdin.end()

   app.on(.activate) with {} ->
      if main-window === null:
         create-window(options)
