
require:
   buche-tools ->
      BucheError
      TrivialScheduler
   .format ->
      format2 as fmt

globals:
   HTMLElement
   Element
   Text
   Node
   document

provide:
   ElementAnalyzer
   attribute-types
   children-types
   UnifiedChannel
   default-analyzer
   channel-analyzer


tag-name(elem) =
   if Text? elem:
      '--text'
   else:
      elem.tag-name.to-lower-case()


run-spec(spec, *args) =
   if spec.run:
      spec.run(*args)
   else:
      spec(*args)


jsclass ElementAnalyzer:

   constructor(*settings) =
      {
         .attribute-defaults
         .attribute-spec
         .children-spec
      } each field ->
         this[field] and r = {=}
         settings each s ->
            r &: (s[field] or {=})

   get-attribute-spec(name) =
      spec = @attribute-spec
      match spec[name]:
         undefined? -> spec.__default
         x -> x

   get-child-spec(tag) =
      spec = @children-spec
      match spec[tag]:
         undefined? -> spec.__default
         x -> x

   set-attribute(name, value) =
      v = match @get-attribute-spec(name):
         false? ->
            throw Error('Attribute {name} is invalid.')
         == true ->
            value
         spec ->
            spec(value)
      #set{name, v}

   dispatch-child(child) =
      tag = tag-name(child)
      msg = match @get-child-spec(tag):
         false? ->
            throw Error('Tag {tag} is invalid here.')
         == true ->
            message = {
               command = .push
               format = .direct
               content = child
            }
            #message{message}
         #set{target, spec} ->
            #set{target, run-spec(spec, child)}
         #message{spec} ->
            #message{run-spec(spec, child)}

   apply(data, match) =
      #set{k, v} ->
         data[k] = v
      #message{m} ->
         data.messages.push(m)

   run(elem) =
      data = (___ & @attribute-defaults) with {
         command = tag-name(elem)
         messages = {}
      }

      elem.attributes each attr ->
         @apply(data) with @set-attribute(attr.name, attr.value)

      elem.child-nodes each child ->
         @apply(data) with @dispatch-child(child)

      data


attribute-types = {
   boolean(x) =
      if x is "":
         true
      else:
         false

   numeric(x) =
      match JSON.parse(x):
         Number? n -> n
         else ->
            throw TypeError('Expected number.')

   json(x) =
      JSON.parse(x)
}


children-types = {
   json(x) =
      data = JSON.parse(x.textContent)
      if Element? data:
         data.command = data.tag-name.to-lower-case()
      data
}


default-analyzer = new ElementAnalyzer with {
   attribute-defaults = {=}
   attribute-spec = {
      __default = false
   }
   children-spec = {
      __default = true
   }
}


channel-analyzer = new ElementAnalyzer(default-analyzer) with {
   attribute-spec = {
      path = true
      subpath = true
   }
}


jsclass UnifiedChannel < HTMLElement:

   ;;;;;;;;;;;;;;
   ;; Analyzer ;;
   ;;;;;;;;;;;;;;

   base-analyzer() =
      channel-analyzer

   attribute-defaults() =
      {=}

   attribute-spec() =
      {=}

   children-spec() =
      {=}

   make-analyzer() =
      new ElementAnalyzer(@base-analyzer()) with {
         attribute-defaults = @attribute-defaults()
         attribute-spec = @attribute-spec()
         children-spec = @children-spec()
      }

   ;;;;;;;;;;;;;;;;
   ;; Scheduling ;;
   ;;;;;;;;;;;;;;;;

   make-scheduler() =
      new TrivialScheduler(@)

   schedule(m) =
      @scheduler.schedule(m)

   dispatch(m) =
      {=> command} = m
      meth = this['dispatch_{command}']
      if meth:
          meth.call(@, m)
      else:
          @missing-command(m)

   missing-command(m) =
      throw new BucheError(
         'Unrecognized command: "{m.command}"'
         m
         {channel = this,
          fields = {'command'}}
      )

   ;;;;;;;;;;;;;;
   ;; Behavior ;;
   ;;;;;;;;;;;;;;

   dispatch_push(m) =
      node = fmt(@, m.format or .text, m.content, m)
      @_append-child(node)

   ;;;;;;;;;;;;;;;;;
   ;; Environment ;;
   ;;;;;;;;;;;;;;;;;

   get-dispatcher() =
      @get-root-node({composed = true}).dispatcher

   get-parent-channel-old() =
      var curr = [@]
      while curr and not curr.channel:
         curr = curr.get-root-node().host
      curr and curr.channel

   get-parent-channel() =
      if @_parent-channel !== undefined:
         return @_parent-channel
      var curr = @parent-node
      while curr and not curr.dispatch-path:
         curr = curr.parent-node
      if not curr:
         curr = @get-parent-channel-old()
      @_parent-channel = curr
      curr

   ;;;;;;;;;;;;;;;
   ;; Callbacks ;;
   ;;;;;;;;;;;;;;;

   attribute-changed-callback(name, oldv, newv) =
      if @connected:
         throw Error('Attributes are frozen.')
      @analyzer.apply(@props) with
         @analyzer.set-attribute(name, newv)

   created-callback() =
      @connected = false
      @scheduler = @make-scheduler()
      @analyzer = @make-analyzer()
      @props = run-spec(@analyzer, @)
      print @props
      delete @props.command
      @innerHTML = ""
      @props.messages each m ->
         @dispatch(m)

   attached-callback() =
      @connected = true
      path =
         if @props.path:
            @props.path
         elif @props.subpath:
            sp = @props.subpath
            match @get-parent-channel():
               false? ->
                  '/{sp}'
               parent ->
                  pp = parent.dispatch-path or parent.path
                  {pp, sp}.join('/')
         else:
            null

      if path:
         @dispatch-path = path
         dispatcher = @get-dispatcher()
         dispatcher.neo-register(path, @)

   detached-callback() =
      if @dispatch-path:
         dispatcher = @get-dispatcher()
         delete dispatcher.channels[@dispatch-path]
         delete @dispatch-path

   ;;;;;;;;;;;;;;;
   ;; Overrides ;;
   ;;;;;;;;;;;;;;;

   _append-child(match) =
      Node? child ->
         super.append-child(child)
      xs ->
         xs each x -> @_append-child(x)

   append-child(child) =
      match @analyzer.dispatch-child(child):
         #set{k, v} ->
            if @connected:
               throw Error('Attributes are frozen.')
            else:
               @analyzer.apply(@props) with
                  @analyzer.set-attribute(k, v)
         #message{m} ->
            @dispatch(m)
